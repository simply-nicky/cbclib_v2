from typing import Iterator, List, Tuple, overload
from ..annotations import BoolArray, IntSequence, NDIntArray, NDRealArray, RealArray, RealSequence
from .label import Regions2D, Structure2D

class Peaks:
    """Peak finding algorithm. Finds sparse peaks in a two-dimensional image.

    Args:
        data : A rasterised 2D image.
        mask : Mask of bad pixels. mask is False if the pixel is bad. Bad pixels are
            skipped in the peak finding algorithm.
        radius : The minimal distance between peaks. At maximum one peak belongs
            to a single square in a radius x radius 2d grid.
        vmin : Peak is discarded if it's value is lower than ``vmin``.

    Attributes:
        size : Number of found peaks.
        x : x coordinates of peak locations.
        y : y coordinates of peak locations.
    """
    radius  : int
    x       : List[int]
    y       : List[int]

    def __init__(self, radius: int): ...

    def __iter__(self) -> Iterator[List[int]]: ...

    def __len__(self) -> int: ...

    def clear(self): ...

    def append(self, x: int, y: int) -> None: ...

    def extend(self, x: IntSequence, y: IntSequence) -> None: ...

    def find_range(self, x: int, y: int, range: int) -> List[int]: ...

    def remove(self, x: int, y: int): ...

class PeaksList:
    def __init__(self): ...

    def __delitem__(self, index: int | slice): ...

    @overload
    def __getitem__(self, index: int) -> Peaks: ...

    @overload
    def __getitem__(self, index: slice) -> 'PeaksList': ...

    @overload
    def __setitem__(self, index: int, value: Peaks): ...

    @overload
    def __setitem__(self, index: slice, value: 'PeaksList'): ...

    def __iter__(self) -> Iterator[Peaks]: ...

    def __len__(self) -> int: ...

    def append(self, elem: Peaks) -> None: ...

    def extend(self, elem: 'PeaksList') -> None: ...

    def index(self) -> NDIntArray: ...

    def x(self) -> NDIntArray: ...

    def y(self) -> NDIntArray: ...

class StreakDouble:
    centers : List[List[int]]
    ends    : List[List[float]]
    id      : int
    value   : List[float]
    x       : List[int]
    y       : List[int]

    def __init__(self, x: int, y: int, structure: Structure2D, data: RealArray): ...

    def center(self) -> List[float]: ...

    def central_line(self) -> List[float]: ...

    def line(self) -> List[float]: ...

    def merge(self, source: 'StreakDouble') -> 'StreakDouble': ...

    def total_mass(self) -> float: ...

    def mean(self) -> List[float]: ...

    def center_of_mass(self) -> List[float]: ...

    def moment_of_inertia(self) -> List[float]: ...

    def covariance_matrix(self) -> List[float]: ...

class StreakFloat:
    centers : List[List[int]]
    ends    : List[List[float]]
    id      : int
    value   : List[float]
    x       : List[int]
    y       : List[int]

    def __init__(self, x: int, y: int, structure: Structure2D, data: RealArray): ...

    def center(self) -> List[float]: ...

    def central_line(self) -> List[float]: ...

    def line(self) -> List[float]: ...

    def merge(self, source: 'StreakFloat') -> 'StreakFloat': ...

    def total_mass(self) -> float: ...

    def mean(self) -> List[float]: ...

    def center_of_mass(self) -> List[float]: ...

    def moment_of_inertia(self) -> List[float]: ...

    def covariance_matrix(self) -> List[float]: ...

class PatternDouble:
    def __init__(self): ...

    def __delitem__(self, index: int | slice): ...

    @overload
    def __getitem__(self, index: int) -> StreakDouble: ...

    @overload
    def __getitem__(self, index: slice) -> 'PatternDouble': ...

    @overload
    def __setitem__(self, index: int, value: StreakDouble): ...

    @overload
    def __setitem__(self, index: slice, value: 'PatternDouble'): ...

    def __iter__(self) -> Iterator[StreakDouble]: ...

    def __len__(self) -> int: ...

    def append(self, elem: StreakDouble) -> None: ...

    def extend(self, elem: 'PatternDouble') -> None: ...

    def to_lines(self, width: RealSequence | None=None) -> NDRealArray: ...

    def to_regions(self) -> Regions2D: ...

class PatternFloat:
    def __init__(self): ...

    def __delitem__(self, index: int | slice): ...

    @overload
    def __getitem__(self, index: int) -> StreakFloat: ...

    @overload
    def __getitem__(self, index: slice) -> 'PatternFloat': ...

    @overload
    def __setitem__(self, index: int, value: StreakFloat): ...

    @overload
    def __setitem__(self, index: slice, value: 'PatternFloat'): ...

    def __iter__(self) -> Iterator[StreakFloat]: ...

    def __len__(self) -> int: ...

    def append(self, elem: StreakFloat) -> None: ...

    def extend(self, elem: 'PatternFloat') -> None: ...

    def to_lines(self, width: RealSequence | None=None) -> NDRealArray: ...

    def to_regions(self) -> Regions2D: ...

Pattern = PatternDouble | PatternFloat

class PatternFloatList:
    def __init__(self): ...

    def __delitem__(self, index: int | slice): ...

    @overload
    def __getitem__(self, index: int) -> PatternFloat: ...

    @overload
    def __getitem__(self, index: slice) -> 'PatternFloatList': ...

    @overload
    def __setitem__(self, index: int, value: PatternFloat): ...

    @overload
    def __setitem__(self, index: slice, value: 'PatternFloatList'): ...

    def __iter__(self) -> Iterator[PatternFloat]: ...

    def __len__(self) -> int: ...

    def index(self) -> NDIntArray: ...

    def to_lines(self, width: RealSequence | None=None) -> NDRealArray: ...

class PatternDoubleList:
    def __init__(self): ...

    def __delitem__(self, index: int | slice): ...

    @overload
    def __getitem__(self, index: int) -> PatternDouble: ...

    @overload
    def __getitem__(self, index: slice) -> 'PatternDoubleList': ...

    @overload
    def __setitem__(self, index: int, value: PatternDouble): ...

    @overload
    def __setitem__(self, index: slice, value: 'PatternDoubleList'): ...

    def __iter__(self) -> Iterator[PatternDouble]: ...

    def __len__(self) -> int: ...

    def index(self) -> NDIntArray: ...

    def to_lines(self, width: RealSequence | None=None) -> NDRealArray: ...

PatternList = PatternDoubleList | PatternFloatList

def detect_peaks(data: RealArray, mask: BoolArray, radius: int, vmin: float,
                 axes: Tuple[int, int] | None=None, num_threads: int=1) -> PeaksList: ...

def filter_peaks(peaks: PeaksList, data: RealArray, mask: BoolArray,
                 structure: Structure2D, vmin: float, npts: int,
                 axes: Tuple[int, int] | None=None, num_threads: int=1): ...

def detect_streaks(peaks: PeaksList, data: RealArray, mask: BoolArray,
                   structure: Structure2D, xtol: float, vmin: float, min_size: int,
                   lookahead: int=0, nfa: int=0, axes: Tuple[int, int] | None=None,
                   num_threads: int=1) -> PatternList:
    """Streak finding algorithm. Starting from the set of seed peaks, the lines are iteratively
    extended with a connectivity structure.

    Args:
        peaks : A set of peaks used as seed locations for the streak growing algorithm.
        data : A 2D rasterised image.
        mask : Mask of bad pixels. mask is False if the pixel is bad. Bad pixels are skipped in the
            streak detection algorithm.
        structure : A connectivity structure.
        xtol : Distance threshold. A new linelet is added to a streak if it's distance to the
            streak is no more than ``xtol``.
        vmin : Value threshold. A new linelet is added to a streak if it's value at the center of
            mass is above ``vmin``.
        log_eps : Detection threshold. A streak is added to the final list if it's p-value under
            null hypothesis is below ``np.exp(log_eps)``.
        lookahead : Number of linelets considered at the ends of a streak to be added to the streak.
        nfa : Number of false alarms, allowed number of unaligned points in a streak.

    Returns:
        A list of detected streaks.
    """
    ...

def p_value(streaks: Pattern, data: RealArray, mask: BoolArray, xtol: float, vmin: float
            ) -> Tuple[RealArray, float]: ...
